using MathOptInterface
const MOI = MathOptInterface
const MOIU = MOI.Utilities
const MOIB = MOI.Bridges

export solve!
MOIU.@model(MOIModel,
            (MOI.ZeroOne, MOI.Integer),
            (),
            (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives, MOI.SecondOrderCone,
             MOI.RotatedSecondOrderCone,
             MOI.PositiveSemidefiniteConeTriangle,),
            (),
            (MOI.SingleVariable,),
            (MOI.ScalarAffineFunction,),
            (MOI.VectorOfVariables,),
            (MOI.VectorAffineFunction,))

function get_MOI_set(cone, length_inds)
    if cone == :SDP
        set = MOI.PositiveSemidefiniteConeTriangle(Int(sqrt(.25 + 2 * length_inds) - .5))
    elseif cone == :Zero
        set = MOI.Zeros(length_inds)
    elseif cone == :Free
        set = MOI.Reals(length_inds)
    elseif cone == :NonNeg
        set = MOI.Nonnegatives(length_inds)
    elseif cone == :NonPos
        set = MOI.Nonpositives(length_inds)
    elseif cone == :SOC
        set = MOI.SecondOrderCone(length_inds)
    elseif cone == :SOCRotated
        set = MOI.RotatedSecondOrderCone(length_inds)
    elseif cone == :ExpPrimal
        set = MOI.ExponentialCone()
    elseif cone == :ExpDual
        set = MOI.DualExponentialCone()
    else
        error("Cone $cone not found somehow")
    end
    return set
end

function get_MOI_constr(T, A_part, b_part, vars)
    # `VectorAffineTerm`s corresponding to the part of the constraint matrix `A` that
    # lies in the current cone
    minus_A_terms = let
        I, J, V = findnz(A_part)
        [ MOI.VectorAffineTerm(I[k], MOI.ScalarAffineTerm(-1 * V[k], vars[J[k]]))
                        for k = eachindex(I, J, V) ]
    end

    # the constraint function generated by `A[inds, :]`
    return MOI.VectorAffineFunction{T}(minus_A_terms, b_part)
end

function load_MOI_model!(model, problem::Problem{T}) where {T}
    c, A, b, cones, var_to_ranges, vartypes, conic_constraints = conic_problem(problem)

    # all variables in the problem
    vars = MOI.add_variables(model, length(c))

    # `ScalarAffineTerm`s corresponding to non-zero entries in the objective function `c`
    obj_terms = let
        I, J, V = findnz(c)
        [  MOI.ScalarAffineTerm(V[k], vars[I[k]]) for k = eachindex(I, V) ]
    end

    # the objective
    obj = MOI.ScalarAffineFunction{T}(obj_terms, zero(T))

    MOI.set(model, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{T}}(), obj)
    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)

    # b - A*x ∈ K1 == cones

    bfull = vec(Array(b))

    sets = Any[ get_MOI_set(cone, length(inds)) for (cone, inds) in cones ]

    constrs = Any[ get_MOI_constr(T, A[inds, :], bfull[inds], vars) for (cone, inds) in cones ]

    # x ∈ K2 == vartypes
    for (ind, vartype) in enumerate(vartypes)
        if vartype == :Bin
            push!(sets, MOI.ZeroOne())
            push!(constrs, MOI.SingleVariable(vars[ind]))
        elseif vartype == :Int
            push!(sets, MOI.Integer())
            push!(constrs, MOI.SingleVariable(vars[ind]))
        end
    end

    MOI.add_constraints(model, constrs, sets)

    return var_to_ranges
end


function solve!(problem::Problem{T}, optimizer::MOI.ModelLike;
    check_vexity = true,
    verbose = true) where {T}

    if check_vexity
        vex = vexity(problem)
    end

    model = MOIU.CachingOptimizer(MOIModel{T}(), MOIU.MANUAL)
    var_to_ranges = load_MOI_model!(model, problem)

    universal_fallback = MOIU.UniversalFallback(MOIModel{T}())
    optimizer = MOIU.CachingOptimizer(universal_fallback, optimizer)
    optimizer = MOI.Bridges.full_bridge_optimizer(optimizer, T)

    MOIU.reset_optimizer(model, optimizer);
    MOIU.attach_optimizer(model);
    MOI.optimize!(model)

    moi_populate_solution!(model, problem, var_to_ranges)
    # # populate the status, the primal (and possibly dual) solution
    # # and the primal (and possibly dual) variables with values
    # populate_solution!(m, problem, var_to_ranges, conic_constraints)
    if problem.status != MOI.OPTIMAL && verbose
        @warn "Problem status $(problem.status); solution may be inaccurate."
    end
    
end

function moi_populate_solution!(model::MOI.ModelLike, problem, var_to_ranges)
    status = MOI.get(model, MOI.TerminationStatus())
    dual_status = MOI.get(model, MOI.PrimalStatus())
    primal_status = MOI.get(model, MOI.DualStatus())

    # should check when this is allowed
    objective = MOI.get(model, MOI.ObjectiveValue())


    if primal_status != MOI.NO_SOLUTION
        vars = MOI.get(model, MOI.ListOfVariableIndices())
        primal = MOI.get(model, MOI.VariablePrimal(), vars)
    else
        primal = fill(NaN, MOI.get(model, MOI.NumberOfVariables()))
    end

    # if dual_status != MOI.NO_SOLUTION
    #     dual = Vector{T}()
    #     for (F, S) in MOI.get(model, MOI.ListOfConstraints())
    #         constr_inds = MOI.get(model, MOI.ListOfConstraintIndices{F,S}())
    #         dual_value = MOI.get(model, MOI.ConstraintDual(), constr_inds)
    #         @show dual_value
    #         # append!(dual, dual_value)
    #     end
    #     problem.solution = Solution(primal, dual, status, objective)
    # else
    # end
    problem.solution = Solution(primal, status, objective)
    if (problem.head == :maximize)
        problem.solution.optval = -problem.solution.optval
    end

    problem.optval = problem.solution.optval
    problem.status = problem.solution.status

    populate_variables_moi!(problem, var_to_ranges)

end


# this is somehow working! But it's the same as MBP version even though 
# MathOptInterface packs them differently than MathProgBase
# todo: figure out why this works still
function populate_variables_moi!(problem::Problem, var_to_ranges::Dict{UInt64,Tuple{Int,Int}})
    x = problem.solution.primal
    for (id, (start_index, end_index)) in var_to_ranges
        var = id_to_variables[id]
        sz = var.size
        if var.sign != ComplexSign()
            var.value = reshape(x[start_index:end_index], sz[1], sz[2])
            if sz == (1, 1)
                var.value = var.value[1]
            end
        else
            real_value = reshape(x[start_index:start_index + div(end_index - start_index + 1, 2) - 1], sz[1], sz[2])
            imag_value = reshape(x[start_index + div(end_index - start_index + 1, 2):end_index], sz[1], sz[2])
            var.value = real_value + im * imag_value
            if sz == (1, 1)
                var.value = var.value[1]
            end
        end
    end
end
